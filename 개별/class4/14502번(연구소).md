[백준 14502번 문제](https://www.acmicpc.net/problem/14502)

### 문제
연구소에 벽 3개를 설치해 바이러스 확산을 최대한 막았을 때의 최대 안전 영역 크기를 구하는 완전탐색+BFS 시뮬레이션 문제

### 풀이
```
package test;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main {
	static int[][] map;
	static List<int[]> virus;
	static List<int[]> zeros;
	static List<List<int[]>> walls;
	static boolean[] used;
	static boolean[][] visited;
	
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken()); // N은 지도의 세로 크기
        int M = Integer.parseInt(st.nextToken()); // M은 지도의 가로 크기
        map = new int[N][M];
        
        // 2번 바이러스 위치 저장하는 배열 만들기
        // 0번 빈칸 위치 저장하는 배열 만들기
        // 새로 만들 1번 벽 3개 위치 조합 만들기
        // 벽 3개 만들 때마다 탐색하기
        virus = new ArrayList<>();
        zeros = new ArrayList<>();
        walls = new ArrayList<>();
        
        for(int i = 0; i < N; i++) {
        	st = new StringTokenizer(br.readLine());
        	for(int j = 0; j < M; j++) {
        		int input = Integer.parseInt(st.nextToken());
        		map[i][j] = input;
        		
        		if(input == 0) {
        			zeros.add(new int[]{j, i});
        		}
        		if(input == 2) {
        			virus.add(new int[]{j, i});
        		}
        	}
        }
        
        used = new boolean[zeros.size()];
        List<int[]> cur = new ArrayList<>();
        permute(cur, 0);
        
        
        
        bw.flush();
        bw.close();
        br.close();
    }
    
    static void bfs(int[] start) {
    	Queue<int[]> queue = new LinkedList<>();
    	queue.add(start);
    	
    	
    }
    
    static void permute(List<int[]> cur, int level) {
    	if(cur.size() == 3) {
    		walls.add(cur);
    		return;
    	}
    	
    	for(int i = level; i < zeros.size(); i++) {
    		if(!used[i]) {
    			used[i] = true;
    			cur.add(zeros.get(i));
    			permute(cur, i + 1);
    			cur.remove(cur.size() - 1);
    			used[i] = false;
    		}
    	}
    }
}
```

### 고민했던 사항 
- 
- 